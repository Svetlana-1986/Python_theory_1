# Рекурсия – определение, описание, изображение какого-либо объекта или процесса внутри самого этого объекта или
# процесса, то есть ситуация, когда объект является частью самого себя.

# Мы уже знаем, что рекурсивная функция — это такая функция, которая в процессе выполнения вызывает саму себя.
# Также мы узнали, что бесконечно вызывать саму себя функция не может, поскольку есть ограничение на глубину рекурсии.
# Поэтому любая рекурсия имеет два основных аспекта:
#
# базовый случай
# рекурсивный шаг.

Задачи:

# 1. Сумма натуральных чисел
# Напишите рекурсивную функцию summa, которая будет суммировать все числа от 1 до N.
# Число N поступает внутрь функции в качестве аргумента

def summa(digit: int) -> int:
    if digit == 0:
        return 0
    return digit + summa(digit - 1)

print(summa(4))

# 2. Напишите рекурсивную функцию find_min, которая найдет наименьшее число в списке. Для этого функция принимает
# в качестве аргумента список для поиска наименьшего значения

def find_min(numbers):
    # Если в списке только один элемент, то он и есть минимальный
    if len(numbers) == 1:
        return numbers[0]
    # Сравниваем первый элемент с минимальным элементом оставшейся части списка
    else:
        current = numbers[0]
        rest_min = find_min(numbers[1:])
        return current if current < rest_min else rest_min

numbers = [10, 32, 24, 17, -5, 10, -22]
print(find_min(numbers))

# 3. Напишите функцию sum_recursive, которая принимает на вход одномерный список из целых чисел и возвращает сумму
# элементов переданного списка. Не забывайте, что реализовать это нужно при помощи рекурсии.

def sum_recursive(*lst: list[int]) -> int:
    if len(*lst) == 1: # распаковываем * tuple, остается list и определяется len
        return lst[0][0]
    return lst[0][0] + sum_recursive(lst[0][1:])

print(sum_recursive([1, 2, 3]))

# 4. Напишите функцию sum_digits, которая находит сумму всех цифр переданного натурального числа n
def sum_digits(digit: int) -> int:
    if digit == 0:
        return 0
    return int(digit % 10) + sum_digits(int(digit / 10))

print(sum_digits(345))

# 5. Двойной факториал
# Необходимо написать рекурсивную функцию double_fact, которая принимает на вход целое число и вычисляет значение
# двойного факториала по формуле:

def double_fact(n: int) -> int:
    if n <= 0:
        return 1
    return double_fact(n - 2) * n

print(double_fact(6))

# 5. Числа Фибоначчи
# Последовательностью Фибоначчи называется последовательность чисел a0, a1, ..., an, ..., где число, стоящее на n-ой
# позиции можно вычислить по формуле:

# Требуется найти N-е число Фибоначчи при помощи рекурсивной функции fibonacci
#
# Функция должна принимать порядковый номер N и возвращать N-ое число Фибоначчи

def fibonacci(n: int) -> int:
    """Числа Фибоначчи — это последовательность, где каждое число является суммой двух предыдущих."""

    if n == 0:  # 0 и 1 есть всегда в этой последова-ти, поэтому это базовый случай
        return 0
    if n == 1:
        return 1
    return fibonacci(n - 1) + fibonacci(n - 2)  # Сумма двух предыдущих чисел. В выражении fibonacci(5) = fibonacci(4) + fibonacci(3) программа сперва
    # вызывает рекурсивно fibonacci(4) и fibonacci(3), а затем возвращает их сумму. Каждый из этих вызовов, в свою
    # очередь, вызывает более мелкие значения до тех пор, пока не дойдем до базовых случаев (когда n == 0, n == 1)

print(fibonacci(10))

# 6. Числа Трибоначчи
# Ваша задача - написать рекурсивную функцию tribonacci, которая принимает на вход целое число n - порядковый номер чисел
# Трибоначчи. Функция по параметру n должна вычислить и вернуть значение, стоящее на n-м месте в ряде чисел Трибоначчи

def tribonacci(n: int) -> int:
    """Числа Трибоначчи — это последовательность, где каждое число является суммой трех предыдущих."""
    if n == 0 or n == 1: #базовые случаи, т.к. последов-ть 0, 0, 1, 1, 2, 4, 7, 13, 24, 44, 81, 149, 274, 504..., n -это индексы для данной последовательности
        return 0
    elif n == 2:
        return 1
    else:
        return tribonacci(n - 1) + tribonacci(n - 2) + tribonacci(n - 3)

print(tribonacci(9))

# 7. Число сочетаний
# Ваша задача - написать рекурсивную функцию get_combin, которая принимает на вход два целых числа  и находит
# C(N,K) — число сочетаний из N элементов по K — с помощью рекуррентного соотношения:

def get_combin(n, k):
    # Базовые случаи,
    if k == 0 or k == n:
        return 1
    # Рекурсивное вычисление
    return get_combin(n - 1, k - 1) + get_combin(n - 1, k)

print(get_combin(10, 7))

#8. Визуализация стека вызова при рекурсии

call_stack = []

def sum_to(n):
    # до начала логики программы
    call_stack.append({'n': n})  # добавляем текущий контекст
    print(call_stack)  # смотрим, что в call_stack
    # отрабатывает сама логика программы
    if n == 1:
        return n
    result = sum_to(n - 1) + n
    # после рекурсивного вызова
    call_stack.pop()  # очищаем call_stack от текущего контекста
    print(call_stack)  # смотрим, что в call_stack
    return result


print(sum_to(5))

# 9.Проверка на вхождение через рекурсию
# Перепишите реализацию функции is_member через рекурсию. Напоминаю, функция is_member  должна проверять,
# есть ли значение value в линейном списке lst.
#
# Функция is_member должна вернуть True, если значение value присутствует в списке lst, и False в противном случае.
#
# Гарантируется, что список lst не будет вложенным

def is_member(value, lst):
    # Базовый случай: если список пуст, вернуть False
    if not lst:
        return False
    # Если первый элемент списка равен искомому значению, вернуть True
    if lst[0] == value:
        return True
    # Рекурсивно вызвать функцию для оставшегося списка
    return is_member(value, lst[1:])

print(is_member(10, [1, 23, 3, 43, 10, 35]))

# 10. Наибольший общий делитель
# Перед вами реализация функции gcd, которая находит наибольший общий делитель при помощи итерации
def gcd(a: int, b: int) -> int:
    while b:
        a, b = b, a % b
    return a
Перепишите данную программу при помощи рекурсии

def gcd(a: int, b: int) -> int:
    """суть алгоритма Евклида: a всегда становится равным предыдущему b, а b становится остатком от деления a на b."""
    if b == 0:
        return a
    return gcd(a = b, b = a % b)

#def gcd(a: int, b: int) -> int:
    #while b:  # Пока b не равно нулю
        #a, b = b, a % b  # Обновляем a и b
    #return a  # Возвращаем значение a, когда b становится 0
print(gcd(7, 19))

# 11.Проверка на палиндром
# Напишите рекурсивную функцию is_palindrome, которая при помощи рекурсии определяет, является ли переданное слово
# палиндромом. Во время проверок регистр букв не учитывайте.

def is_palindrome(word: str) -> bool:
    # Приводим строку к нижнему регистру для игнорирования регистра
    word = word.lower()

    # Базовый случай 1: если слово пустое или из одной буквы, это палиндром
    if len(word) <= 1:
        return True

    # Базовый случай 2: если первый и последний символы не равны, это не палиндром
    if word[0] != word[-1]:
        return False

    # Рекурсивный случай: проверяем подстроку без первого и последнего символа
    return is_palindrome(word[1:-1])

print(is_palindrome('Racecar'))

# 12. Арифметическая прогрессия - 2
# Теперь ваша задача написать функцию get_arith_progression так, чтобы она могла находить n-ое число для произвольной арифметической последовательности. Для этого функция get_arith_progression должна иметь следующие обязательные параметры:
#
# a1 - первый элемент последовательности
# d - разность последовательности
# n - порядковый номер элемента, который необходимо найти в арифметической прогрессии.

def get_arith_progression(a1: int, d: int, n: int) -> int:
    # Базовый случай:
    if n == 1:
        return a1
    # Рекурсивный случай: текущий элемент прогрессии + сумма предыдущих
    return d + get_arith_progression(a1, d, n - 1)

print(get_arith_progression(4, 2, 3))

# Рекурсия и вложенные объекты

def get_total(lst):
    total = 0
    for value in lst:
        # проверяем тип элемента
        if isinstance(value, list):
            # если это список, то
            # вызываем рекурсивный шаг для
            # нахождения суммы его элементов
            sum_nested = get_total(value)
            total += sum_nested
        else:
            # Если это число, то сразу добавляем к total
            total += value

    return total

print(get_total([1, 2, 3, 4, 5]))
print(get_total([[1, 2, 3], [4, [5, 6]], 7]))
print(get_total([1, 2, 3, 4, 5,
                 [6, 7, 8,
                  [9, 1, [2, [3], 4], 5, 6]]]))