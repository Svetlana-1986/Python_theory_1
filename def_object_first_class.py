# Функции как объекты первого класса
# Объект называют «объектом первого класса», если:
#
# С ним можно работать как с переменными
# Он может быть передан в функцию как аргумент
# Он может быть возвращен из функции как результат
# Он может быть включен в другие структуры данных. Например, быть элементом словаря или списка

# Функции можно сохранять в переменные
# Функция представляет собой такой же объект, как и обычная строка или список. Поэтому как и любой другой объект
# можете присвоить ее переменной.
def say_louder(text):
    print(text.upper() + '!')

# сохраняем в переменную shout ссылку на объект-функцию say_louder
shout = say_louder

say_louder('Hello')
shout('aloha')
print(shout) # увидим ссылку на функцию say_louder

# В нем мы определяем функцию say_louder, которая выводит переданный ей текст в верхнем регистре.
# Далее мы сохраняем ссылку на функцию say_louder в переменную shout. После этого мы можем вызывать функцию как
# по ее исходному имени, так и через переменную shout.
#
# Мы можем даже удалить имя первоначальной функции через оператор del
# Но функцию по-прежнему можно будет вызвать через переменную shout

def say_louder(text):
    print(text.upper() + '!')

shout = say_louder

say_louder('Hello')
shout('aloha')
print(shout)

del say_louder

# Если раскомментировать, возникнет исключение NameError
# say_louder('Messi')

shout('Maldini')

# Вы даже можете проверить, что переменная shout ссылается именно на функцию say_louder. К каждой функции python
# прикрепляет строковый идентификатор (имя функции) во время создания в целях отладки. Вы можете получить доступ
# к этому внутреннему идентификатору с помощью специального атрибута __name__:

def say_louder(text):
    print(text.upper() + '!')

shout = say_louder

print(say_louder.__name__)
print(shout.__name__)

Функции можно передавать другим функциям
Вы можете передавать функции в качестве аргументов другим функциям. Взгляните на пример ниже

def speak(func):
    message = func('Меж нами памяти туман, ты как во сне')
    print(message)
#
# Здесь функция speak имеет обязательный параметр func, в него мы будем передавать функцию. Параметр func является
# локальной переменной и будет хранить в себе ссылку на функцию. Через переменную func мы будем вызывать переданную
# функцию и сохранять ее результат в переменную message. Это происходит в этой строке

message = func('Меж нами памяти туман, ты как во сне')

def say_louder(text):
    return text.upper() + '!'


def say_camel_case(text):
    return text.title() + '!'


def speak(func):
    message = func('Меж нами памяти туман, ты как во сне')
    print(message)


speak(say_louder)
speak(say_camel_case)
#
# В момент передачи указываете только имя функции без оператора вызова (). Тем самым вы передаете объект функции.
# Если же сделаете вызов speak(say_louder()), то в функцию speak будет передана не функция say_louder,
# а результат работы вызова функции say_louder

# Функции могут возвращать другие функции
# Функции могут возвращать другие функции. Для демонстрации такого примера нам необходимо определить вложенные функции -
# это такая функция, определение которой находится внутри другой функции. Ничего сложного тут нет, тот же блок def
# внутри другого блока def.\

def get_type_speak(mode=0):
    def say_louder(text):
        return text.upper() + '!'

    def say_camel_case(text):
        return text.title() + '!'

    if mode == 0:
        return say_louder
    return say_camel_case


func_speak = get_type_speak()

print(func_speak('Позови меня с собой'))
print(func_speak.__name__) # say_louder


another_func_speak = get_type_speak(5)
print(another_func_speak('Я приду сквозь злые ночи'))
print(another_func_speak.__name__) # say_camel_case

# Функции могут храниться в структурах данных
# Мы можем функции сохранять в качестве элементов любых коллекций, изученных нами ранее.
#
# Вот пример, где мы создаем список из функций,
#
# funcs = [sum, say_louder, say_camel_case]
#
# причем используем как встроенные функции, так и пользовательские

def say_louder(text):
    return text.upper() + '!'


def say_camel_case(text):
    return text.title() + '!'


funcs = [sum, say_louder, say_camel_case]
print(funcs)

print(funcs[1])
print(funcs[1]('А ты такой холодный'))
print(funcs[2]('Как айсберг в океане'))
print(funcs[0]([1, 2, 3]))

# Обращаясь по индексу 1, мы получаем доступ к функции say_louder, далее можно сразу добавить оператор вызова и передать
# \аргументы в функцию, как мы и сделали этой командой funcs[1]('А ты такой холодный')

def get_square(x):
    return x * x

def get_cube(x):
    return x * x * x

funcs = {
    'Квадрат': get_square,
    'Куб': get_cube,
}

value = 5
for key_func in sorted(funcs):
    print(key_func, funcs[key_func](value))

print(funcs['Квадрат'](10))

# Здесь создан словарь funcs, где к ключам мы привязали функции. Через ключ «Квадрат» получаем доступ к функции get_square,
# что дает нам право делать вызов:
# funcs['Квадрат'](10)

def do_something(text):
    text = text.split()
    return [word[0].upper() for word in text]


def print_something(func):
    result = func('прости меня моя любовь')
    print('.'.join(result))


print_something(do_something)
#П.М.М.Л


def square(x):
    return x ** 2

def apply(func):
    return func(7)

result = apply(square)
print(result)
#49

def red():
    print('Нео выбрал красную таблетку')


def blue():
    print('Нео выбрал синюю таблетку')


colors = {
    1: blue,
    2: red,
}

colors[2]()
#Нео выбрал красную таблетку
\
# Что увидим на экране после выполнения данного кода?
def red():
    return 'Color is red'

def green():
    return 'Color is green'

def blue():
    return f'Color is blue'

colors = {}
colors[green] = '00FF00'
colors[blue] = '0000FF'
colors[red] = 'FF0000'

for i in colors:
    print(i()) #вызов функции получается

#Color is green
# Color is blue
# Color is red


# Запоминание результата
# Представь, что ты работаешь в компании, которая занимается разработкой программного обеспечения. Твой начальник дал
# тебе задание написать программу, которая будет вычислять факториал числа. Факториал числа - это произведение всех
# натуральных чисел от 1 до этого числа. Например, факториал числа 5 равен 1 * 2 * 3 * 4 * 5 = 120.
#
# Однако, есть одно условие: ты должен сохранить результат вычисления факториала в глобальной переменной, чтобы его
# можно было использовать в других частях программы. Это означает, что значение факториала будет доступно для
# использования в других функциях или блоках кода.

# Также, твой начальник хочет, чтобы программа была оптимизирована и не вычисляла факториал числа каждый раз заново.
# Вместо этого, программа должна проверять, вызывалась ли уже функция с таким параметром. Если функция уже вызывалась с
# таким параметром, то программа должна вернуть сохраненное значение, а не вычислять его заново. Также перед возвратом
# такого значения функция должна вывести на экран «Get from cache value factorial(n)»
#
# Таким образом, твоя задача - написать функцию factorial, которая будет вычислять факториал числа, сохранять результат
# в глобальной переменной и проверять, вызывалась ли уже функция с таким параметром.

rez_f = {}
def factorial(n):
    if n not in rez_f:
        num = 1
        for i in range(1, n+1):
            num *= i
        rez_f.setdefault(n, num)
        return num
    if n in rez_f:
        return f"Get from cache value factorial({n})\n{rez_f[n]}"

print(factorial(5))
print(factorial(6))
print(factorial(5))




