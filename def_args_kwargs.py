# Когда вы используете параметр *args, все переданные в момент вызова значения упакуются в один кортеж и сохранятся
# в параметр args. И сколько бы значений вы не передали, все они сохранятся в переменной args обязательно в виде кортежа

def my_func(*args):
    print(type(args))
    print(f'{args=}')
    print('-' * 15)


my_func(1, 2, 3, 4)
my_func(1, 2,)
my_func()
my_func(1)
my_func([4, 5, 6])
my_func({1: 100, 2: 200, 3: 300})

# Научившись принимать любое количество позиционных аргументов, мы можем обрабатывать их внутри функции по своему
# усмотрению. Например, можно подсчитать сумму всех чисел, которые были переданы в момент вызова функции:
def get_sum(*args):
    s = 0
    for i in args:
        s += i
    print(s)


get_sum(1, 2, 3, 4, 5, 6)
get_sum()
get_sum(20, 40, 30)
#
# Напишите функцию count_args, которая принимает произвольное количество аргументов.
# Данная функция должна возвращать количество переданных ей на вход аргументов
#
# Вам необходимо написать только определение функции count_args

def count_args(*args):
    return len(args)

print(count_args(1, 2, 3, 4, 5))
#
# Напишите функцию multiply, которая принимает произвольное количество числовых аргументов.
# Данная функция должна находить произведение всех переданных значений и возвращать его в качестве результата
#
# При вызове multiply без параметров должен возвращаться результат 1.

def multiply(*args):
    rez = 1
    if len(args) > 0:
        for i in range(len(args)):
            rez *= args[i]
        return rez
    return rez

print(multiply(1, 2, 3, 4, 5, 6))

# Напишите функцию check_sum, которая принимает произвольное количество аргументов типа int.
#
# Данная функция должна вывести на экран фразу «not enough», если сумма всех элементов меньше 50,
# в противном случае нужно вывести «verification passed»
#
# Вам необходимо написать только определение функции check_sum

def check_sum(*args):
    summ = 0
    for i in range(len(args)):
        summ += args[i]
    if summ < 50:
        print("not enough")
    else:
        print("verification passed")

check_sum(10, 10, 10, 10, 9)

# Напишите функцию is_only_one_positive, которая принимает произвольное количество числовых аргументов
# и возвращает True, когда из всех переданных значений только одно положительное, в противном случае верните False
#
# Вам необходимо написать только определение функции is_only_one_positive

def is_only_one_positive(*args):
    plus = 0
    for i in range(len(args)):
        if args[i] > 0:
            plus += 1
    if plus == 1:
        return True
    return False

print(is_only_one_positive(-1, -2, -3, -4))

#
# Давайте теперь создадим функцию print_goods, которая печатает список покупок. На вход она будет принимать произвольное
# количество значений, а товаром мы будем считать любые непустые строки. Следовательно, все числа, списки, словари и
# другие нестроковые объекты вам нужно будет проигнорировать.
#
# Функция print_goods должна печатать список товаров в виде: «<Порядковый номер товара>. <Название товара>».
# На примерах ниже вы можете посмотреть как должна работать функция print_goods

# print_goods('apple', 'banana', 'orange')
# # Программа должна вывести следующее:
# 1. apple
# 2. banana
# 3. orange
#
# print_goods(1, True, 'Грушечка', '', 'Pineapple')
# # Программа должна вывести следующее:
# 1. Грушечка
# 2. Pineapple
#
# В случае, если среди переданных значений не встретится ни одного товара, необходимо распечатать фразу «Нет товаров»
#
# print_goods([], {}, 1, 2)
# # Программа должна вывести следующее:
# Нет товаров

def print_goods(*args):
    fin_goods = []
    for i in range(len(args)):
        if isinstance(args[i], str) and len(args[i]) > 0:
            fin_goods.append(args[i])
    if len(fin_goods) > 0:
        for i, v in enumerate(fin_goods, start=1):
            print(f"{i}. {v}")
    else:
         print("Нет товаров")
        
print_goods('apple', 'banana', 'orange')

**KWARGS распаковывает словарь

# так как мы передали одно значение словаря, а функция ожидала принять три значения. Для того, чтобы все отработало
# верно, нужно в момент вызова сделать распаковку словаря при помощи оператора **

def print_person_info(name, age, company):
    print(f"{name=}, {age=}, {company=}")


artem = {"name": "Artem", "age": 33, "company": "Magnit"}
print_person_info(**artem)
#
# При использовании параметра **kwargs все имена аргументов, переданные в момент вызова, и их  значения будут упакованы
# в один словарь и сохранены в параметр kwargs.

# Вместо трех параметров name, age, company создадим один параметр **kwargs, который нам позволит принимать произвольное
# количество именованных аргументов. Теперь мы можем распаковывать словари различной длины в момент вызова функции
# и/или передавать именованные аргументы

def print_person_info(**kwargs):
    pairs = [f'{k}={v}' for k, v in kwargs.items()]
    print(', '.join(pairs))

bob = {"name": "Bob", "age": 25}
print_person_info(**bob)

artem = {"name": "Artem", "age": 33,
         "company": "Magnit", 'hobby': 'soccer'}
print_person_info(**artem)

print_person_info(lastname='Egorov', name='Артем', music=['Rock', 'Indi'])

print_person_info(lastname='Egorov', **bob)

# Напишите функцию concatenate(), которая принимает произвольное число именованных аргументов и объединяет их в одну
# большую строку без разделителей.
# Вам необходимо написать только определение функции concatenate
# Обратите внимание, что передаваемые значения могут быть различных типов данных

def concatenate(**kwargs):
    rez = [f'{v}' for k, v in kwargs.items()]
    return "".join(rez)

print(concatenate(a="Я", b="Выучу", c="Этот", d="Питон", e="!"))

# Не сотвори себе кумира
# Напишите функцию create_actor, которая принимает произвольное количество именованных аргументов и возвращает словарь
# с характеристиками актера. Если функции create_actor не передавать никаких аргументов, то она должна возвращать базовый
# словарь с ключами name, surname, age. Вот так он выглядит:

# create_actor() -> {
#         'name': 'Райан',
#         'surname': 'Рейнольдс',
#         'age': 47,
#     }
#
# Если передавать именованные параметры, которые отсутствуют в базовом словаре, они дополняются к этому словарю
# Если передавать именованные параметры, которые совпадают с ключами базового словаря, то значения в словаре должны
# заменяться переданными значениями:

def create_actor(**kwargs):
    base_dict = {'name': 'Райан', 'surname': 'Рейнольдс','age': 47,}
    for k, v in kwargs.items():
        if k not in base_dict:
            base_dict.setdefault(k, v)
        if k in base_dict:
            base_dict[k] = v
    return base_dict

actor = create_actor(
    height=190,
    movies=['Дедпул', 'Главный герой']
)
print(actor)
#
# Напишите функцию info_kwargs, которая принимает произвольное количество именованных аргументов.
#
# Функция info_kwargs должна распечатать именованные аргументы (каждый на новой строке) в виде пар «ключ = значение»,
# где ключи должны следовать в алфавитном порядке.
#
# Вам необходимо написать только определение функции info_kwargs

def info_kwargs(**kwargs):
    sort = sorted(kwargs.items())
    sorted_dict = dict(sort)
    for k, v in sorted_dict.items():
        print(f"{k} = {v}")

info_kwargs(first_name="John", last_name="Doe", age=33)