# lambda (Анонимная функция) — это функция, которая определена без имени.
#
# В то время как обычные функции определяются с помощью ключевого слова def в Python, анонимные функции определяются
# с помощью ключевого слова lambda. Синтаксис создания анонимных функций выглядит следующим образом:
# lambda arg1, arg2, … : выражение
#
# После ключевого слова lambda перечисляются параметры функций, можно использовать args и kwargs. После перечисления
# параметров ставится знак двоеточия  и затем указывается выражение, которое будет возвращаться из функции.

# def get_square(n):
#     return n**2
# или
#
# lambda x: x**2

# Присваивание lambda-функции в переменную. Обычно так не делают - это в учебных целях
#
# get_square = lambda x: x**2
# print(get_square(4))
# print(get_square(10))

# Лямбда-функции полезны в использовании в тех случаях, когда необходимо написать функцию в одну строчку. Они могут
# принимать любое количество аргументов, но возвращать только одно значение в виде выражения. Они не могут содержать
# команды или несколько выражений.

# Условный оператор if может быть применен в анонимных функциях, но с небольшой натяжкой. Так как в lambda-функции имеется
# лимит в одно выражение, то условный оператор необходимо переписать через тернарный оператор. Значит вот такую функцию
def get_sign(x):
    if x > 0:
        return 'positive'
    return 'negative or 0'

# можно переписать через анонимную функцию следующим образом
get_sign = lambda x: 'positive' if x>0 else 'negative or 0'

# Еще можно использовать анонимную функцию без параметров
h = lambda: 'hello'
print(h()) #всегда возвращать строку «hello».

# В принципе возвращаемое значение может отсутствовать в анонимной функции

surprise = lambda: print('surprise')
print(surprise())

# Эквивалент коду
def surprise():
    print('surprise')
    return None

# Не забывайте, что любая функция в python должна возвращать значение. Если в явном виде ничего не возвращается,
# значит ждите значение None.

# Функции, возвращающие булево значение
ef is_adult(age):
    return age >= 18

# или

is_adult = lambda age: age >= 18

# Логические операторы or, and, not без проблем можно использовать с целью создания более сложного условия.
# Главное для анонимной функции - оставаться в рамках одной инструкции.

# Одноразовое использование
def get_square(n):
    return n**2

def increment(n):
    return n+1

def apply(func, x):
    return func(x)

print(apply(get_square, 7))
print(apply(get_square, 6))
print(apply(increment, 5))
print(apply(increment, 4))

# или

def apply(func, x):
    return func(x)


print(apply(lambda x: x ** 2, 7))
print(apply(lambda x: x ** 2, 6))
print(apply(lambda n: n + 1, 5))
print(apply(lambda n: n + 1, 4))

# Особенно отлично анонимные функции сочетаются с:
#
# функцией map
# функцией filter
# функцией reduce
# сортировками коллекций

# Аннотации lambda функции - Согласно pep-3107  lambda функции не поддерживают аннотации типов внутри себя

# Задача: В переменную starts_with присвойте lambda функцию, которая принимает строку и возвращает True, когда переданная
# строка начинается с буквы «W». Во всех остальных случаях нужно возвращать False
# Ничего кроме создания переменной starts_with делать не нужно.

starts_with = lambda s: True if s.startswith('W', 0, 1) else False

print(starts_with('when'))
print(starts_with.__name__)

# False
# <lambda>

# В переменную check_word присвойте lambda функцию, которая принимает строку и возвращает True, если переданная строка
# начинается с букв «Q» или «R» и заканчивается любой из гласных «A», «E», «I», «U» или «O». Регистр во время проверок
# не должен иметь значения
#
# Во всех остальных случаях нужно возвращать False

check_word = lambda s: True if s.upper().startswith(('Q', 'R')) and s.upper().endswith(('A', 'E', 'I', 'O')) else False

print(check_word('raid'))
print(check_word.__name__)

# False
# <lambda>

# Помните задачу «Проверка на високосность»?
#
# Ваша задача реализовать данную функцию при помощи lambda оператора
#
# Полученную функцию сохраните в переменную is_leap

is_leap = lambda year: True if year % 4 == 0 and year % 100 != 0 or year % 400 == 0 else False

# Хорошо постарались с прошлой задачей! Однако мы забыли, что скидка должна быть только для тех товаров, стоимость
# которых больше 50. Вам стоит внести это изменение в прошлый код

sale_lambda = lambda x: x * 0.9 if x > 50 else x

print(sale_lambda(60.0))
print(sale_lambda.__name__)

54.0
<lambda>




