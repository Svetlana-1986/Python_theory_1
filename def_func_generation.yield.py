# Генератор-функция - функция, возвращающая объект генератор-итератор. Эта функция выглядит как обычная, за исключением
# того, что в ней содержится одно или несколько выражений yield для генерации значений, которые можно использовать
# в цикле for или которые можно извлекать по одному с помощью функции next.
# В результата вызова функции-генератора будет получен объект GeneratorType, который представляет собой итератор-генератор.

# Генератор-итератор запоминает места прерывания, когда он генерирует свои значения при помощи оператор yield.
# При следующем вызове next генератор-итератор начнет исполнение кода с того места, где он прервался, и будет работать
# до следующего оператора yield. Если после своего возобновления работы генератор не встретит yield, то он выполнит все
# оставшиеся инструкции и в конце выдаст исключение StopIteration.
#
# Помимо места прерывания генератор-итератор сохраняет, запоминает и фиксирует все значения локальных переменных.
# Поэтому когда next запросит сгенерировать новое значение, генератор-итератор начнет выполнение не только с места
# последнего оператора yield, но и в его распоряжении будут все локальные переменные в том же состоянии на момент,
# когда был сгенерирован предыдущий элемент. Обычные же функции уничтожают все свои локальные переменные после того,
# как функция вернет результат.

# Если вы используете версию python 3.3 или свежее (скорее всего, так и есть), вы можете использовать операторы
# return и yield внутри одной функции. Такая функция будет являться генератором-функции, а слово return позволяет
# выполнить преждевременное завершение работы генератора за счет автоматического возникновения исключения StopIteration.

def generate_even(limit):
    i = 0
    while i <= limit:
        yield i
        i += 2

for value in generate_even(10):
    print(value)

# Генерация бесконечной последовательности чисел

def infinite_gen():
    i = 1
    while True:
        yield f"Hello {i}"
        i += 1

gen = infinite_gen()
print(next(gen))  # Hello 1
print(next(gen))  # Hello 2
print(next(gen))  # Hello 3

# Вы будете получать по одному значению, но только по запросу функции next. Но делать запросы к такому генератору
# можно бесчисленное количество раз.
# Если вы передадите такой генератор в цикл for, то он будет выполняться бесконечно

# Задачи:
def gen_odd(n):
    i = 1
    while i <= n:
        yield i
        i += 2

for value in gen_odd(5):
    print(value)

# 2. Функция range - 1
# Ваша задача создать функцию-генератор my_range_gen, которая имеет один параметр n.
# Функция my_range_gen должна генерировать по порядку все числа от 0 до n не включительно. В общем,
# быть копией встроенной функции range, вызванной от одного аргумента.

def my_range_gen(n: int):
    count = 0
    while count < n:
        yield count
        count += 1

for value in my_range_gen(5):
    print(value)

# 3. Генератор квадратов
# Ваша задача создать функцию-генератор gen_squares, которая принимает аргумент n и генерирует квадраты чисел
# от 1 до n включительно. Ниже несколько вариантов использования:

def gen_squares(n):
    for square in range(1, n + 1):
        yield square * square

for i in gen_squares(9):
    print(i)

#  4. Генератор бесконечной арифметической прогрессии
# Ваша задача создать функцию-генератор gen_arithmetic_progression, которая при вызове принимает два значения:
#
# первый элемент прогрессии
# разность элементов прогрессии
# Функция-генератор gen_arithmetic_progression должна выдавать элементы бесконечной арифметической прогрессии
# с учетом переданных значений

def gen_arithmetic_progression(element: int, difference):
    value = element
    while True:  # Бесконечный цикл для генерации последовательности
        yield value
        value += difference  # Добавляем разность к текущему значению

count = 8
for value in gen_arithmetic_progression(105, -5):
    print(value)
    count -= 1
    if count == 0:
        break

# 5. Генератор последовательности Фибоначчи
#
# Ваша задача создать функцию-генератор gen_fibonacci_numbers, которая принимает аргумент n и генерирует
# n-ое количество чисел Фибоначчи.
#
# Будем считать, что последовательность Фибоначчи такая: 1, 1, 2, 3, 5, 8, 13, 21, 34, ...

def gen_fibonacci_numbers(n: int):
    a, b = 1, 1  # Инициализируем первые два числа Фибоначчи
    for _ in range(n):  # Выполняем цикл n раз, чтобы сгенерировать n чисел Фибоначчи
        yield a  # Возвращаем текущее число Фибоначчи
        a, b = b, a + b  # Обновляем значения для следующих чисел Фибоначчи: a становится текущим b, b становится a+b, где а предыдущее значение, b из цикла (num)


for num in gen_fibonacci_numbers(5):  # Генерируем и печатаем первые 5 чисел Фибоначчи
    print(num)

# 6. Генератор факториалов
def gen_factorial(n: int):
    fact = 1
    for i in range(1, n + 1):
        fact *= i
        yield fact

for value in gen_factorial(5):
    print(value)

# 7. Генератор факториалов - 2

# Измените генератор-функцию gen_factorial так, чтобы он стал выдавать бесконечную последовательность факториалов

def gen_factorial():
    fact = 1  # Начальное значение факториала
    digit = 1  # Начальное число, с которого начнем вычисление факториала
    while True:  # Бесконечный цикл
        fact *= digit  # Умножаем текущее значение факториала на текущее число
        yield fact  # Возвращаем текущее значение факториала
        digit += 1  # Переходим к следующему числу

count = 1
for value in gen_factorial():
    print(value)
    count += 1
    if count > 10:
        break

# 8. Если у вас есть итерируемый объект, который слишком велик для того, чтобы полностью поместиться
# в памяти (например, при работе с большими файлами), возможность дробить его на небольшие фрагменты и затем использовать
# их за раз может быть очень ценной.
#
# С этой задачей должна справиться функция-генератор chunker. Она должна принимать итерируемый объект и выдавать
# фрагмент указанного размера за раз.

def chunker(iterable, size):
    """Генератор, который делит итерируемый объект на фрагменты размером size."""
    for i in range(0, len(iterable), size):  # Двигаемся start, stop, по шагам size
        yield iterable[i:i + size]  # Возвращаем фрагмент (срез) списка

for chunk in chunker(range(25), 4):
    print(list(chunk))

# 9. Функция range - 2
# Измените функцию-генератор my_range_gen так, чтобы она могла вызываться от одного или двух аргументов.
#
# Если вызов происходит от одного аргумента n, то my_range_gen  генерирует все числа от 0 до n не включительно.
#
# Если вызов происходит от двух аргументов a и b, то my_range_gen  генерирует все числа от a включительно
# до b не включительно.

def my_range_gen(a, b=0):
    if b == 0:
        count = 0
        while count < a:
            yield count
            count += 1
    elif b != 0:
        count = a
        while count < b:
            yield count
            count += 1
for value in my_range_gen(5):
    print(value)