# Как называть и оформлять функции

# В версии python 3.12 всего существует 35 ключевых слов. Это число может незначительно меняться с течением времени и отличаться от прежних версий python.
#
# В Python ключевые слова чувствительны к регистру. Все ключевые слова, кроме True, False и None, написаны строчными буквами и должны быть написаны как есть. Список всех ключевых слов приведен ниже.
#
# False      await      else       import     pass
# None       break      except     in         raise
# True       class      finally    is         return
# and        continue   for        lambda     try
# as         def        from       nonlocal   while
# assert     del        global     not        with
# async      elif       if         or         yield

# При попытке назвать функцию именем ключевого слова вы получите исключение SyntaxError,
# и pycharm подчеркнет имя вашей функции красным

# Мягкие ключевые слова
# Некоторые идентификаторы зарезервированы только в определенных контекстах. Они известны как мягкие ключевые слова.
#
# Опять же в различных версиях python могут быть разные ключевые слова, конкретно в версии 3.12 идентификаторы match,
# case, type и _ могут синтаксически действовать как ключевые слова в определенных контекстах, но это различие
# осуществляется на уровне синтаксического анализатора.
#
# В качестве мягких ключевых слов их использование в грамматике возможно при сохранении совместимости с существующим
# кодом, который использует эти имена в качестве имен-идентификаторов.

# Функция должна выполнять только одну операцию. Она должна выполнять ее хорошо. И ничего другого она делать
# не должна. Если функция выполняет только те действия, которые находятся на одном уровне под
# объявленным именем функции, то эта функция выполняет одну операцию.

# Тогда правильнее было бы назвать такую функцию print_and_get_squares. Но переименование не решит проблемы единичной
# ответственности, потому что ваша функция не сконцентрирована на одной операции. Следует разделить такую функцию на две:
def get_squares(number):
    return [i ** 2 for i in range(1, number + 1)]

def print_squares(number):
    for i in range(1, number + 1):
        print(f'Квадрат числа {i} равен {i ** 2}')

# Теперь у вас есть отдельные функции, каждая из которых хорошо выполняет свою работу. И если вам все еще необходимо
# создать функцию, которая и печатает и возвращает квадраты, вы можете создать ее из двух новых функций.
# Словно детали конструктора вы добавляете в тело функции вызовы необходимых функций

def print_and_get_squares(number):
    print_squares(number)
    return get_squares(number)

# Функции всегда определяются вверху вашей программы. Если вы определяете несколько функций, между ними должно
# стоять две пустые строки
# Будьте последовательны в выражениях возврата: либо все операторы return в функции должны возвращать выражение, либо
# ни один из них не должен. Если какой-либо оператор return возвращает выражение, то оставшиеся операторы return тоже
# должны явно возвращать значение, не смотря на то, что python по умолчанию возвращает None.

# Корректное оформление

def foo(x):
    if x >= 0:
        return math.sqrt(x)
    else:
        return None

def bar(x):
    if x < 0:
        return None
    return math.sqrt(x)

# Проверка на палиндром
# Определите функцию is_palindrome, которая принимает строку и отвечает на вопрос, является ли она палиндромом или нет
# Палиндромом считается слова, которые читаются одинаково слева направо и справа налево, как например слово «радар»
# При проверке не нужно учитывать регистр букв, это значит, что слова «радар» и «Радар» считаются одинаковыми.
# Также во входной строке могут встречаться пробелы, их необходимо исключить из проверки. Остальные знаки пунктуации,
# такие как запятые, точки, дефисы и т.д., во входных данных отсутствуют.

def is_palindrome(s):
    s = s.lower()
    s = s.split()
    x = "".join(s)
    if x == x[::-1]:
        return True
    return False

print(is_palindrome("Never Odd or Even"))

# Проверка на високосность
# Напишите функцию is_leap, которая проверяет является ли переданный год високосным или нет.
#
# Год является високосным, если он соответствует следующим правилам:
#
# Годы, делящиеся на 100 без остатка, не являются високосными, за исключением годов, которые делятся на 400 без остатка.
# Например, 1900 год не является високосным, а 2000 год — является.
# Годы делящиеся на 4 без остатка (например, 2016, 2024), являются високосными.
# Напишите только определение функции is_leap

def is_leap(year):
    if year % 100 == 0 and year % 400 != 0:
        return False
    elif year % 400 == 0:
        return True
    if year % 4 == 0:
        return True
    else:
        return False

# Количество високосных лет
# Напишите функцию count_leap_years, которая принимает два года y1 и y2, причем y1 <= y2,
# и возвращает количество високосных лет в промежутке от y1 включительно до  y2 не включительно.
#
# При реализации функции count_leap_years, используйте ранее созданную функцию is_leap
#
# Напишите только определения необходимых функций

def is_leap(y1, y2):
    count = 0
    for i in range(y1, y2):
        if i % 400 == 0 and i % 4 == 0:
            count += 1
        elif i % 400 == 0:
            count += 1
        elif i % 4 == 0 and i % 100 != 0:
            count += 1
        else:
            pass
    return count
print(is_leap(2000))

def count_leap_years(y1, y2):
    return is_leap(y1, y2)

print(count_leap_years(1890, 2021))

# Проверка регистрации
#
# Напишите функцию register_check, которая проверяет сколько человек успешно прошло регистрацию на мероприятие.
# Функция принимает словарь в качестве параметра, состоящий из имен людей(ключи) и результатов
# регистрации(значения ключа).
#
# Если человек успешно прошел регистрацию, то в словаре напротив его имени хранится значение «yes», иначе «no».
#
# Функция register_check должна возвращать количество только тех людей, кто успешно зарегистрировался.

def register_check(people):
    count = 0
    for i in people:
        if people[i] == 'yes':
            count += 1
    return count

people = {'Igor': 'yes', 'Stas': 'no', 'Peter': 'no', 'Mary': 'yes'}
print(register_check(people))

# Пересечение списка
# Определите функцию overlapping, которая принимает два списка и возвращает True, если у них есть хотя бы один общий
# элемент, в противном случае — False.
#
# ВЫ можете решать задачу удобным для вас способом, но попробуйте реализовать с использованием функции is_member
# из предыдущего шага.

def is_member(value, lst):
    for i in range(len(value)):
        if value[i] in lst:
            return True
    return False


def overlapping(value, lst):
    return is_member(value, lst)

print(overlapping(['this', 'might', 'work'], ['or', 'maybe', 'this']))

