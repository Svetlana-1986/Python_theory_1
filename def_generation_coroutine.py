# Сопрограммы
# Генераторы, которые получают данные от вызывающей стороны, называются корутинами (или сопрограммами).

def coroutine():

    print('Start')
    msg = (yield)  # указание получения данных
    yield msg.upper()  # возврат данных из генератора
    print('Finish')


coro = coroutine()  # создаем генератор

# поскольку сопрограмма является генератором
# код внутри не будет выполняться, пока не вызовем функцию next

next(coro)  # после этого перемещаемся к первому yield внутри функции-генератора

# метод .send() позволяет отправлять данные в сопрограмму
# это отправляет "hello" в первый yield
# поэтому переменной msg внутри coroutine будет присвоено это значение
result = coro.send("hello")

# Но наша сопрограмма также сразу сгенерирует msg.upper()
# Значит, в result сохранится это значение
print(result)  # HELLO

# next(coro)
def coroutine():
    print('Start')
    msg = (yield)  # указание получения данных
    yield msg.upper()  # возврат данных из генератора
    print('Finish')


coro = coroutine()  # создаем генератор
next(coro)
result = coro.send("hello")
print(result)

# next(coro) # Если раскомментировать, увидим текст Finish и возникнет
# исключение StopIteration

# Оператор yield и передача данных
# Ниже приведен пример сопрограммы, использующей yield для возврата значения источнику до момента отправки значения
# метода .send(). Тогда в момент инициализации мы сразу получим значение, стоящее справа от первого оператора yield.

# В нем видно, что когда мы переместили сопрограмму

def coroutine():
    value = yield 'World'
    print(f'Получено значение = {value}')

coro = coroutine()
next(coro)
next(coro)

#Получено значение = None

# Двойственность оператора yield
# Теперь мы знаем, что оператор yield может использоваться как для получения данных в сопрограмму, так и для отправки
# данных из нее. Такая вот у него двойственная натура. Но она позволяет делать интересные вещи, суть которых заключается
# в одновременном приеме и отправке данных. Взгляните на пример

def coroutine():
    value = 0
    while True:
        value = yield value ** 2
        print(f'Получено значение = {value}, отправлено {value ** 2}')

# Интерес представляет следующая строка:
#
# value = yield value ** 2
# Как только выполнение сопрограммы дойдет до этой строки, yield отправит значение, стоящее справа от себя и приостановит
# свою работу. Как только в сопрограмму отправят значение через метод .send(), сопрограмма возобновит свою работу
# с этого места и сохранит переданное значение в локальную переменную value.

def coroutine():
    value = 0
    while True:
        value = yield value ** 2
        print(f'Получено значение = {value}, отправлено {value ** 2}')


coro = coroutine()
value_from_coro = next(coro)
print('Получено при инициализации', value_from_coro)
value_from_coro = coro.send(1)
print('Получено после 1й отправки', value_from_coro)
value_from_coro = coro.send(2)
print('Получено после 2й отправки', value_from_coro)
value_from_coro = coro.send(3)
print('Получено после 3й отправки', value_from_coro)
value_from_coro = coro.send(4)
print('Получено после 4й отправки', value_from_coro)
value_from_coro = coro.send(5)
print('Получено после 5й отправки', value_from_coro)
coro.close()

# Получено при инициализации 0
# Получено значение = 1, отправлено 1
# Получено после 1й отправки 1
# Получено значение = 2, отправлено 4
# Получено после 2й отправки 4
# Получено значение = 3, отправлено 9
# Получено после 3й отправки 9
# Получено значение = 4, отправлено 16
# Получено после 4й отправки 16
# Получено значение = 5, отправлено 25
# Получено после 5й отправки 25

# Примеры
def power(rank: int) -> int:
    while True:
        value = (yield)
        yield value ** rank

get_square = power(2)
next(get_square)
values = [5, 3, 6, 7, 9]
for item in values:
    square = get_square.send(item)
    print(square)
    next(get_square)

# 25
# 9
# 36
# 49
# 81

# Задачи
# Число-палиндром
# Ваша задача — создать сопрограмму is_palindrome, которая проверяет поступающее ей натуральное число на палиндром.
#
# Числа поступают в сопрограмму при помощи метода send. Сопрограмма должна порождать значение True, если
# число одинаково можно записать слева направо и справа налево, в противном случае - значение False.
#
# Вам необходимо написать только определение функции-сопрограммы is_palindrome.

def is_palindrome():
    digit = yield #
    while True:
        digit_str = str(digit) #send(1771)
        result = digit_str == digit_str[::-1]  # Проверка палиндрома
        digit = yield result  # Возвращаем результат проверки

coro = is_palindrome()
next(coro)     Это запускает генератор до первого yield
print(coro.send(1771)) send(1771) передает значение 1771 в переменную digit внутри генератора

# coro = is_palindrome()
# next(coro)
# print(coro.send(1771))
# print(coro.send(1))
# print(coro.send(1234321))

# Нахождение среднего арифметического
# Ваша задача — создать корутину get_average, которая накапливает среднее арифметическое переданных в нее чисел.
#
# Числа поступают в корутину при помощи метода send, корутина должна порождать текущее накопленное значение среднего
# арифметического.
#
# Вам необходимо написать только определение функции-корутины get_average.

def get_average():
    total = yield  # Сумма всех чисел
    count = 1  # Количество чисел

    while True:
        number = (yield total / count)  # Отправляем текущее среднее
        total += number  # Обновляем сумму
        count += 1  # Увеличиваем количество чисел

coro = get_average()
next(coro)
print(coro.send(10))
print(coro.send(20))
print(coro.send(6))

# Проверка пароля
# Ваша задача — создать сопрограмму check_password, которая проверяет поступающий ей пароль на безопасность.
#
# С точки зрения безопасности будет подходить пароль, для которого одновременно выполняются следующие условия:
#
# длина не менее 10 символов;
# должна присутствовать хотя бы одна заглавная буква латинского алфавита;
# должна присутствовать хотя бы одна цифра;
# должен присутствовать хотя бы один служебный символ из набора !, @, #, $, %.
# Пароли в виде строки поступают в сопрограмму при помощи метода send. Сопрограмма должна порождать значение True,
# если пароль соответствует всем перечисленным условиям, в противном случае - значение False.
#
# Вам необходимо написать только определение функции-сопрограммы check_password.

def check_password():
    password = yield  # Получаем новый пароль
    while True:
        password = yield (len(password) >= 10 and any(char.isupper() for char in password) and
                          any(char.isdigit() for char in password) and any(char in "!@#$%" for char in password))

coro = check_password()
next(coro)
print(coro.send('qwerty'))
print(coro.send('qwertyuiop'))
print(coro.send('qwerty1234'))
print(coro.send('qwerty123!'))
print(coro.send('qwerty123?'))
print(coro.send('Qwerty123?'))
print(coro.send('Qwerty123@'))


