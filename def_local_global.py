# Глобальная переменная — это такая переменная, которая определена вне функции.
# Слово «глобальный» означает, что к данной переменной можно получить доступ как внутри, так и вне функции.

global_var = 'Я глобальная переменная'

def my_func_1():
    print("Первая функция:", global_var)

def my_func_2():
    print("Вторая функция:", global_var)

my_func_1()
my_func_2()
print('Глобальная область видимости:', global_var

Локальная переменная — это такая переменная, которая объявлена внутри тела функции
Внутри функции вы можете спокойно обращаться к ее локальным переменным и изменять их значения.
Не видна также будет локальная переменная одной функции внутри другой

def my_func():
    s = "Мне нравится этот курс"
    print(f"Локальная переменная: {s=}")

my_func()

# Локальные переменные создаются каждый раз при входе в функцию и уничтожаются при выходе из нее.

# Одинаковые имена локальных и глобальных переменных
# Вполне может быть такая ситуация, что будет создана глобальная и локальная переменная с одинаковым именем.
# Тогда важна область видимости, где используется переменная: если обращаетесь вне функции (в глобальной области видимости),
# вы получите значение глобальной переменной. Внутри функции (в локальной области видимости) доступ будет осуществляться
# к локальной переменной.

variable = 'Я глобальная переменная' # создаем глобальную переменную


def my_func():
    variable = 'Я локальная переменная' # создаем локальную переменную
    print("Внутри функции", variable)


print('Вне функции:', variable)
my_func()
print('Вне функции:', variable)

# Всегда, когда вы видите ошибку UnboundLocalError, знайте, что вы столкнулись с проблемой глобальных и локальных
# переменных. В большинстве случаев вам поможет инструкция global, которую мы разберем далее.

# Явное изменение глобальной переменной при помощи оператора global
# В python существует ключевое слово global, которое позволяет  создавать глобальные переменные и изменять их в локальной
# области видимости.
#
# Все достаточно просто, вы указываете в самом верху тела функции какие имена переменных функция должна расценить как
# глобальные. Вот к примеру, следующий код создает две глобальные переменные, которые не существовали до момента вызова
# функции

name, age = 'Artem', 33


def my_func():
    global age
    name = 'Kolya'
    age = 25
    print(name, age)


print(name, age)
my_func()
print(name, age)

value = 10

def increase_5():
    global value
    value += 5

print('Перед вызовом:', value)
increase_5()
print('После вызова:', value)

# Неявное изменение глобальной переменной
# С неявным изменением глобальных переменных вы можете столкнуться в ситуациях, когда передаете изменяемые объекты
# в аргументы функции. Все дело в том, что в момент вызова идет сопоставление аргумента функции к соответствующему
# параметру. Как мы узнали в предыдущем уроке сопоставление осуществляется либо по позиции параметра, либо по его имени.
# Далее при помощи операции присваивания значение из аргумента попадает в параметр. А в python мы помним, что переменные
# хранят не сами значения, а ссылки на значения.

def my_func(first, second, third):
    print('-' * 20)
    print('Адреса локальных переменных:')
    print(f'{first=}', id(first))
    print(f'{second=}', id(second))
    print(f'{third=}', id(third))


a = 100
b = [10, 20, 30]
c = {"Hello": 'Привет'}

print('Адреса глобальных переменных:')
print(f'{a=}', id(a))
print(f'{b=}', id(b))
print(f'{c=}', id(c))

my_func(a, b, c) # вызов функции

# Параметры являются локальными переменными и они определяются в момент вызова функции. В параметры присваиваются
# ссылки на объекты, переданные в аргументы

# Следовательно делаем вывод, что в параметры попадают ссылки на объекты, которые были переданы в качестве аргументов.
# Вот взгляните на пример ниже. Здесь вам необходимо обратить внимание, что значения идентификаторов глобальных переменных
# и параметров совпадают

# И раз в параметрах сохраняется ссылка на переданный в момент вызова объект, то, имея дело с изменяемыми объектами,
# мы можем спокойно изменить состояние объекта. Допустим добавить новые элементы в глобальный список через локальную
# переменную

value = [1, 2, 3]


def my_func(x):
    x.append(10)


my_func(value)
print(value)

# Рекомендации по изменению глобальных переменных
# Общая рекомендация следующая: старайтесь избегать явного или тем более неявного изменения значения глобальных переменных
# внутри функции. Потому что такие изменения при работе в большом проекте бывает трудно отследить
#
# Если функция должна поменять какую-то переменную, то лучше это сделать через возвращаемое значение функцией с последующим
# присваиванием.

age = 33


def get_new_age():
    return 25


age = get_new_age()
print(age)

# Панграмма ли это?
# Панграмма — это предложение, которое содержит все буквы алфавита хотя бы один раз. В нашем задании мы будем
# рассматривать в качестве алфавита буквы английского языка. Тогда одним из примеров панграммы будет фраза
# «The quick brown fox jumps over the lazy dog».
#
# Ваша задача здесь — написать функцию is_pangram для проверки предложения на предмет того, является ли оно панграммой
# или нет. Для проверок внутри функции вы можете пользоваться глобальной переменной alpha. Символы, которые не являются
# буквами, необходимо игнорировать.

alpha = 'abcdefghijklmnopqrstuvwxyz'

def is_pangram(s):
    s = s.split()
    s = "".join(s)
    s = s.lower()
    pangram = []
    for i in s:
        if i in alpha and i.isalpha() and i not in pangram:
            pangram.append(i)
        else:
            pass
    if len(pangram) == 26:
        return True
    return False

#print(is_pangram("How quickly daft jumping zebras vex!"))

# Rövarspråket
# Rövarspråket (со шведского переводится как «язык разбойника») - шведская языковая игра. Она стала популярной после
# книг Астрид Линдгрен о Билле Бергсоне, где дети используют ее в качестве кода, как в игре, так и при раскрытии настоящих
# преступлений.
#
# Формула кодирования проста: каждая согласная удваивается, а между ними вставляется буква o. Гласные остаются нетронутыми.
#
# Тогда согласно этим правилам слово
#
# stubborn
#
# превратится в
#
# sostotubobboborornon
#
# Ваша задача написать функцию translate_to_robber_lang(), которая будет переводить текст на «язык разбойника»
# (по-шведски ).
# Все символы, которые не являются буквами, должны оставаться без изменения.

vowel = ['a','e', 'i', 'o', 'u'] #гласная
consonant = ['B','b','C','c','D','d','F','f','G','g','H','h','J','j','K','k','L','l','M','m','N','n','P', 'p', 'Q', 'q','R','r', 'S','s','T','t','V','v','W','w','X','x','Y','y','Z','z']

def translate_to_robber_lang(s):
    rez = ''
    for i in s:
        if i in consonant:
            rez += i + "o" + i
        else:
            rez += i
    return rez
print(translate_to_robber_lang("This is kinda fun"))

# Резервация столов
# Продолжаем автоматизировать работу ресторана. Следующий этапом является резервация(закрепление) свободного столика
# за клиентом и отмена брони. Структура хранения резерваций все та же в виде словаря:
tables = {
    1: 'Andrey',
    2: None,
    3: 'Gena',
    4: 'Artem',
    5: 'Vasiliy',
    6: None,
    7: 'Artur',
    8: None,
    9: 'Misha',
}


def reserve_table(num, name):
    if tables[num] is None:
        tables[num] = name


def delete_reservation(num):
    tables[num] = None
print(tables)
delete_reservation(1)
delete_reservation(3)
reserve_table(6, 'Chubaka')
print(tables)

# Резервация столов: изменение требований
# Через некоторое время менеджеры ресторана поняли, что помимо имени клиента, они бы еще хотели хранить его принадлежность
# к статусу VIP клиента. Соответственно, они бы хотели изменить структуру хранения резерваций на следующую:

tables = {
    1: {'name': 'Andrey', 'is_vip': True},
    2: None,
    3: None,
    4: None,
    5: {'name': 'Vasiliy', 'is_vip': False},
    6: None,
    7: None,
    8: None,
    9: None,
}


def reserve_table(num, name, is_vip):
    if tables[num] == None:
        tables[num] = {'name': name, 'is_vip': is_vip}


def delete_reservation(num):
    tables[num] = None


print(tables)
reserve_table(3, 'Gena', True)
reserve_table(4, 'Artem', False)
reserve_table(5, 'Artur', True)  # Артур не должен занять место Василия
print(tables)