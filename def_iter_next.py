# Знакомство с итераторами
# Итерация – это процесс перебора элементов объекта в цикле.
# «Итерируемый объект» - это объект, который поддерживает итерацию.
# Из него следует, что любой объект, который можно обойти при помощи цикла for, является итерируемым.
# Из базового курса по python мы знаем, что любой тип данных, представляющий собой коллекцию элементов, а именно
#
#      ✔️ строки
#
#      ✔️ списки
#
#      ✔️ кортежи
#
#      ✔️ множества
#
#      ✔️ словари
#
#      ✔️ неизменяемые множества
#
# можно использовать в цикле for. Следовательно, любой из перечисленных объектов является итерируемым.
# Вы можете без проблем обойти элементы этих коллекций в цикле for
# В python любой объект, который может взаимодействовать со встроенной функцией iter() ,
# будет считаться итерируемым объектом.
my_set = {4, 3, 3, 4, 3, 2, 1, 2}
iterator = iter(my_set)
print(iterator)
# < set_iterator object >
# Именно при помощи функции iter вы можете определить, что результат вызова range является итерируемым объектом
iterator = iter(range(4))
print(iterator)
# И значит его можно обходить в цикле for

for value in range(4):
    print(value)

# Функция iter()
# «Итератор» - это специальный объект-перечислитель, обязанность которого заключается в перемещении по элементам
# коллекции. Итератор выдает по одному следующий элемент последовательности; когда элементов больше не останется,
# он выбросит исключение StopIteration.

# В python любой объект, который может взаимодействовать со встроенной функцией next, будет считаться итератором.
# Чтобы создать итератор вам необходимо вспомнить про встроенную функцию iter. Она создаст итератор на основании
# любого итерируемого объекта, а уже далее полученный итератор можно передавать в функцию next

my_str = 'qwerty'
iterator = iter(my_str)
print(next(iterator))
print(next(iterator))
print(next(iterator))

# Как в python реализован цикл for
# Цикл for при помощи функции iter запрашивает у объекта его итератор. А итератор - это механизм, который описывает
# правила и порядок обхода элементов. Любой итерируемый объект может предоставить итератор.
# Далее цикл for, получив от объекта итератор, будет получать следующий элемент итератора при помощи функции next,
# обрабатывая при этом возможное возникновение ошибки окончания коллекции StopIteration.
#
# Из выше описанного следует, что такой с виду простой код как

s = 'Python'
for letter in s:
    print(letter)
на самом деле за кулисами языка python цикл for представляет собой следующее

s = 'Python'

it = iter(s)
while True:
    try:
        print(next(it))
    except StopIteration:
        del it
        break
# Здесь мы создаем итератор от итерируемого объекта (в нашем случае строки) и далее в бесконечном цикле while
#     вызываем функцию next от итератора. Это будет продолжаться до тех пор, пока итератор выдает элементы.
#     Как только итератор опустеет, он выбросит исключение StopIteration, и мы завершим бесконечный цикл.

# Количество итераций
# после исчерпания всех своих элементов итератор становится пустым. Дальнейшая попытка обойти элементы такого итератора
# ничего не даст, будет выполнено ноль итераций во втором цикле
s = 'Hello'
it = iter(s)

for i in it:
    print(i)

print('----')

for i in it:
    print(i)

# Для повторного обхода элементов потребуется создать новый итератор и по нему проитерироваться.
s = 'Hello'

for i in iter(s):
    print(i)

print('----')

for i in iter(s):
    print(i)

# Будьте аккуратны с итерацией: такие функции как sum, max, преобразование к типам tuple, str, list неявным образом
# итерируются по элементам в процессе свой работы. Вот почему при повторном вызове функции sum в примере ниже вы ничего
# не увидите

numbers = [1, 2, 3, 4, 5]
iterator = iter(numbers)
print(sum(iterator))
print(sum(iterator))
# а здесь первое преобразование к кортежу пройдет успешно, но в процессе произойдет обход всех элементов итератора.
# Во время преобразования к списку итератор будет уже пуст

numbers = [1, 2, 3, 4, 5]
iterator = iter(numbers)
print(tuple(iterator))
print(list(iterator))

# Занимаемая память
# Итераторы, в отличие от итерируемых объектов, не хранят в себе информацию о всех элементах коллекции. Итератор -
# это не сама коллекция, а механизм обхода элементов или способ получения следующего элемента в коллекции.
# Поэтому итераторы намного эффективнее расходуют память в отличие от итерируемых объектов.

# Где используются итераторы?
# Итераторы настолько часто используются в самом python, что можно даже утверждать, что они повсюду.
# Взгляните только на список встроенных функций, которые  возвращают итератор в качестве результата своей работы:
#
#      ✔️ map
#
#      ✔️ filter
#
#      ✔️ zip
#
#      ✔️ enumerate

