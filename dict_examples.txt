1. Определение самого «дорогого» слова
На вход вашей программе поступают несколько слов через пробел в одной строке. Ваша задача — найти слово с наибольшей суммой значений и 
вывести его в качестве ответа.

Для определения суммы вам доступен словарь alphabet.

words = input().split() 
alphabet = {
    'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6,
    'g': 7, 'h': 8, 'i': 9, 'j': 10, 'k': 11, 'l': 12,
    'm': 13, 'n': 14, 'o': 15, 'p': 16, 'q': 17,
    'r': 18, 's': 19, 't': 20, 'u': 21, 'v': 22,
    'w': 23, 'x': 24, 'y': 25, 'z': 26
}

def word_value(word):
    return sum(alphabet.get(letter, 0) for letter in word)  

max_word = max(words, key=word_value)  

print(max_word)

2 вариант решения

alphabet = {
    'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6,
    'g': 7, 'h': 8, 'i': 9, 'j': 10, 'k': 11, 'l': 12,
    'm': 13, 'n': 14, 'o': 15, 'p': 16, 'q': 17,
    'r': 18, 's': 19, 't': 20, 'u': 21, 'v': 22,
    'w': 23, 'x': 24, 'y': 25, 'z': 26
}
print(max(input().split(), key=lambda w: sum(map(alphabet.get, w))))

Параметр key: key=lambda w: sum(map(alphabet.get, w))

Для каждого элемента (слова) из списка input().split() будет вычисляться значение по ключу, 
которое используется для сортировки.
Разберем это выражение:

lambda w: это анонимная функция, которая принимает один аргумент — 
слово w.
map(alphabet.get, w) — map применяет функцию alphabet.get ко всем символам в слове w.

Задача2
Дан список целых чисел. Напишите программу, которая подсчитывает, сколько раз каждое число встречается в с
писке, и выводит результат в виде словаря, где ключами будут числа из списка, а значениями — количество их вхождений.

Значения списка поступают в одной строке через пробел.

В качестве ответа выведите на экран получившийся словарь.

digits = list(map(int, input().split()))
s_dict = {}

for digit in digits:
    s_dict.setdefault(digit, 0)
    s_dict[digit] += 1

print(s_dict)

Задача3
Ваша задача — написать программу, которая превращает строку в карту буквенных следов. Представьте,
что каждая буква оставляет свои отпечатки (индексы) в строке.

Программа должна:

cоставить досье на каждую букву — в каком месте строки она "побывала";

cобрать полный отчёт, где ключ — это буква, а значение — список мест преступления (индексов).
Пример: если вы введёте «котик», программа расскажет, что буква «к» встречается на 0 и 4 позициях, «о» — на 1,
 «т» — на 2, а «и» — на 3. Даже пробелы и знаки препинания не останутся без внимания! ?

Ваш отчёт должен быть готов в виде словаря. Распечатайте его на экране

s = input()
s_dict = {}

for index, letter in enumerate(s):
    s_dict.setdefault(letter, []).append(index)

print(s_dict)

Задача4
Напишите программу, которая принимает на вход n строк. Каждая строка содержит ключ и, возможно, значение,
 разделённые одним пробелом. Ваша задача — создать в словаре пару на основании введенных данных по следующему принципу:

Если значение отсутствует, создайте в словаре ключ с значением None;

Если один и тот же ключ встречается несколько раз, последующее значение должно заменять предыдущее.
В конце программа должна вывести итоговый словарь.

n = int(input())
s_dict = {}

for _ in range(n):
    s = input().split()
    key = s[0]  # первый элемент - это ключ
    value = ' '.join(s[1:]) if len(s) > 1 else None  # объединяем все остальные элементы в строку

    s_dict[key] = value  # обновляем значение для ключа

print(s_dict)

5
name John
age 25
city New York
country
age 30

Задача2
Напишите программу, которая работает со словарём letters, содержащим числовые значения. Задача программы — найти ключ,
связанный с максимальным значением, и вывести этот ключ на экран.

Гарантируется, что все значения в словаре letters уникальны. Переменная letters вам доступна сразу, ее не нужно
создавать.

letters = {"a": 10, "b": 20, "c": 25, "d": 15}
max_value = max(letters.values())
max_keys = [k for k, v in letters.items() if v == max_value]
print(*max_keys)

Задача3

Фильтрация книг
Вы работаете над проектом для архивации данных о книгах в библиотеке. Каждый ключ в словаре представляет собой
уникальный идентификатор книги, состоящий из случайных букв. Однако из-за требований системы обработки данных нужно
оставить только те книги, чьи идентификаторы состоят из количества символов, кратного трём. Помогите автоматизировать
 этот процесс, написав программу.

Условие:

Напишите программу, которая принимает словарь, где ключами являются идентификаторы книг (строки), а значениями —
информация о книге (например, количество страниц). Создайте и распечатайте новый словарь, содержащий только те книги,
 у которых длина идентификатора кратна 3.

Вам будет предоставлена переменная books.  Ее значение вам видны во входных данных. На основании books нужно будет
 получить подходящие нам книги

 books = {
    'ASDFG': 320,
    'ZXC123': 250,
    'QWE': 110,
    'MNBVCXZ': 410,
    'LKH': 90
}

new_books = {k: v for k, v in books.items() if len(k) % 3 == 0}
print(new_books)

Задача4

Зеркальный словарь
Напишите программу, которая принимает словарь, где ключами являются строки, а значениями — числа. Необходимо создать
"зеркальный" словарь, где ключами будут значения из исходного словаря, а значениями — строки, упорядоченные
лексикографически. Если одно и то же число встречается у нескольких строк, объедините их в список.



Во входных данных будет создаваться уже исходный словарь в переменной data. Вы должны использовать переменную
data для своего решения. Никакого ввода данных делать не нужно.

data = {'apple': 5, 'banana': 3, 'cherry': 5, 'date': 2}

mirror_data = {}

for key, value in data.items():
    if value not in mirror_data:
        mirror_data.setdefault(value, [key])
    else:
        mirror_data[value].append(key)

for key in mirror_data:
    mirror_data[key].sort()

print(mirror_data)

Задача5
Избавляемся от слабых звеньев
В одной компании проводится конкурс для сотрудников, где каждому участнику присваивается уникальный идентификатор (ключ),
а его результат (количество набранных баллов) заносится в словарь. Однако для дальнейшего этапа нужно убрать из списка
всех участников, кто набрал минимальное количество баллов.

Напишите программу, которая обрабатывает словарь scores, в котором хранятся идентификаторы сотрудников (ключи) и
их результаты (значениями). Программа должна выводить новый словарь, из которого удалены все ключи с минимальными
значениями.

scores = {
    'Иванов': 15,
    'Петров': 20,
    'Сидоров': 15,
    'Кузнецов': 25
}

if scores:
    min_scores = min(scores.values())
    max_scores = {k: v for k, v in scores.items() if v != min_scores}
    print(max_scores)
else:
    print("{}")

2 вариант решения
print({k: v for k, v in scores.items() if v > min(scores.values())})

Задача6
Поиск лидеров
Вы — разработчик системы управления корпоративной продуктивностью. Ваша задача — провести в компании анализ
продуктивности сотрудников, где результативность каждого сотрудника измеряется числовым показателем
(количество выполненных задач), умноженным на его "вес" (влияние на общий успех проекта). Ваша задача — определить
сотрудников с наибольшим взвешенным результатом.

Напишите программу, которая обрабатывает переменную scores. В ней хранится словарь, где ключами являются имена
сотрудников, а значениями — кортежи из двух элементов: результат и вес.

Программа должна вывести на экран имя сотрудника с максимальным результатом. Если таких сотрудников несколько,
программа должна вывести список их имён, в котором имена расположены в порядке появления в словаре scores.

Гарантируется, что в scores всегда будет как минимум одно значение.

scores = {
    'Иванов': (50, 1.5),
    'Петров': (75, 1.2),
    'Сидоров': (60, 1.8),
    'Кузнецов': (90, 1.0)
}

full_score = {k: v[0] * v[1] for k, v in scores.items()}
max_full_score = max(full_score.values())
max_rezult = [k for k, v in full_score.items() if v == max_full_score]

if len(max_rezult) <= 1:
    print(*max_rezult)
else:
    print(max_rezult)

Задача7
Продолжение "Буквенного детектива"
Добро пожаловать обратно в "Буквенный детектив", но на этот раз вас ждёт финальная миссия! ?????

В прошлый раз мы раскусили все буквы и выяснили, где они прячутся в строке. Но теперь наша задача ещё сложнее:
 восстановить исходное слово из карты преступлений!

Ваш новый вызов — собрать буквы, разбросанные по карте, в правильном порядке, чтобы вернуть исходное слово.
У вас есть отчёт в виде словаря:

Ключ — это буква, оставившая свои следы;
Значение — это список мест, где её заметили (индексы).
Ваш алгоритм должен:

Аккуратно разместить каждую букву на её место;
Собрать итоговое слово из всех букв;
Убедиться, что все пробелы и пустые места на своём месте — никаких недочётов!
Помните: если вы ошибётесь, то буквенные преступники снова окажутся на свободе. ?

letters = {'a': [0, 3, 5, 7, 10], 'b': [1, 8], 'r': [2, 9], 'c': [4], 'd': [6]}
max_index = max(max(indices) for indices in letters.values())
word = [''] * (max_index + 1)

for k, v in letters.items():
    for index in v:
        word[index] = k

final_word = ''.join(word)
print(final_word)

Задача8
Теперь вы работаете над системой учёта участников мероприятий. В словаре каждому мероприятию (ключ) соответствует
список участников. Ваша задача — реорганизовать данные таким образом, чтобы создать словарь, где:

ключи — это имена участников;

значения — список мероприятий, в которых они участвуют.
Если участник присутствует в нескольких мероприятиях, необходимо указать все соответствующие мероприятия.

Напишите функцию, которая принимает словарь, где значения — списки, а ключи — строки. Функция должна возвращать
 новый словарь, где ключами будут элементы из всех списков, а значениями — списки ключей из исходного словаря.

events = {
    'Выставка': ['Ольга', 'Сергей'],
    'Семинар': ['Сергей', 'Игорь'],
    'Тренинг': ['Ольга', 'Дарья']
}

def new_dict_events(events: dict)-> dict:
    new_dict = {}
    for k, v in events.items():
        for name in v:
            new_dict.setdefault(name, []).append(k)
    return new_dict

print(new_dict_events(events))

 2 вариант решения

my_dict = dict()
for k, v in events.items():
    for name in v:
        my_dict.setdefault(name, []).append(k)

print(my_dict)

3 вариант
from collections import defaultdict

res = defaultdict(list)
for event, names in events.items():
    for name in names:
        res[name].append(event)

print(dict(res))

