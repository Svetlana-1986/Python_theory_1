# Различия между  type и isinstance
# Среди различий этих функций сразу бросается в глаза возвращаемое значение. Но главное отличие этих двух функций
# заключается в наследовании. Здесь мы вновь ступаем на территорию ООП. Все объекты в python находятся в
# определенной иерархии, например тип bool на самом деле является подтипом int. Это значит, что логические типы
# наследуют некоторое поведение целых чисел, например сложение: если попробовать сложить True + True,
# то получите 2. Так вот, объект  type при своей работе не учитывает наследование, в то время как isinstance()
# это делает.

print(type(True), type(True) == bool)  # <class 'bool'> True
print(type(True), type(True) == int)  # <class 'bool'> False

print(isinstance(True, bool))  # True
print(isinstance(True, int))  # True, потому что учитывается наследование


# Ваша задача написать функцию count_strings, которая принимает произвольное количество аргументов.
# Функция должна среди всех переданных значений найти только строки, найти их количество и  вернуть в качестве
# результата.
#
# Ваша задача написать только определение функции count_strings

def count_strings(*args):
    count = 0
    for i in args:
        if isinstance(i, str):
            count += 1
    return count

print(count_strings(1, 2, 'hello', True, 't'))

# Ваша задача написать функцию find_keys, которая принимает произвольное количество именованных аргументов.
# Функция должна отобрать только те имена параметров, у которых значения являются списками или кортежами.
# Функция find_keys должна собрать все имена таких параметров в список, отсортировать их по алфавиту вне зависимости
# от регистра букв и вернуть в качестве результата.

def find_keys(**kwargs):
    sort_list = []
    for k, v in kwargs.items():
        if isinstance(v, (tuple, list)):
            sort_list.append(k)
    return sorted(sort_list, key = lambda x: x.upper())

print(find_keys(t=[4, 5], w=[5, 3], A=(3, 2), a={2, 3}, b=[4]))