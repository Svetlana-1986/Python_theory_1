# Python это язык, поддерживающий динамическую типизацию. Это значит, что одна и та же переменная в разные моменты
# времени может хранить разные типы данных.

# Помните, что в python сами переменные не хранят значения, а в них сохраняется лишь ссылка на объект
#
# Что делать, если мы хотим сообщить себе и другим разработчикам, что в переменной first необходимо сохранять значения
# только определенного типа данных, например тип int? Ведь нужно подсказывать себе на будущее и другим разработчикам
# (и даже иногда самому pycharm) с каким типом данных мы хотим работать в определенной переменной. Для этого и придумали
# аннотации.

# Аннотации – инструмент, позволяющий сделать код более информативным и избавиться от некоторых проблем, связанных
# с динамической типизацией.
# Синтаксис аннотаций впервые появился в python3.5  «PEP 484 – Type Hints» и распространялся только на параметры
# функции и возвращаемые значения. Затем в python3.6 добавили возможность аннотировать переменные в любом участке
# вашей программы, описана эта возможность в «PEP 526 – Syntax for Variable Annotations». С аннотации переменных мы и
# начнем наше обучение.
#
# Чтобы воспользоваться аннотацией, необходимо после имени переменной поставить двоеточие и указать какой тип данных вы
# ожидаете в этой переменной

# переменная: тип_данных
# first: int

# Но стоит так же учитывать, что аннотации не приводят к появлению ошибки, ваш код будет успешно отрабатывать, даже если
# вы сохранили не тот тип данных, который был в аннотации. Динамическую типизацию никто не отменял. Просто редактор кода
# будет показывать предупреждение вам и другим разработчикам о том, что есть несостыковки с типами данных
# first: int
# first = 100
# print(first)
# first = 'hello'
# print(first)
# first = [1, 2, 3]
# print(first)
#
# first: int
# first = 100
# можно заменить одной короткой записью
# first: int = 100

# Аннотация в функциях
# Аннотации широко используются в функциях с целью указания ожидаемых типов данных для параметров функции. Используется
# следующий синтаксис для аннотации параметров функции:
# def имя_функции(параметр1: тип_параметра1, параметр2: тип_параметра2, ...):
#    <тело функции>
#
# def add_numbers(a: int, b: int):
#     return a + b
#
# Помимо параметров в функции можно и нужно аннотировать тип возвращаемого значения. Взгляните на синтаксис такого
# оформления

# def имя_функции(параметр1: тип_параметра1, параметр2: тип_параметра2, ...) -> тип_возврата:
#    <тело функции>
#
# def add_numbers(a: int, b: int) -> int:
#   return a + b
#
# Атрибут __annotations__
#
# У каждой функции имеется специальный атрибут __annotations__ , который позволяет посмотреть аннотации параметров и
# возвращаемого результата. Атрибут __annotations__ хранит данные в виде словаря.
#
#
# def add_numbers(a: int, b: int) -> int:
#     return a + b
#
#
# print(add_numbers.__annotations__)
# {'a': <class 'int'>, 'b': <class 'int'>, 'return': <class 'int'>}

# В атрибут __annotations__  не попадает информация об аннотации локальных переменных, созданных внутри функции. Атрибут
# __annotations__ хранит информацию только о параметрах и возвращаемом значении функции, если у них указана аннотация.
#
# def count_letters(word_1: str, word_2: str) -> int:
#     a: int = len(word_1)
#     b: int = len(word_2)
#     return a + b
#
# print(count_letters.__annotations__)

# {'word_1': <class 'str'>, 'word_2': <class 'str'>, 'return': <class 'int'>}

# Варианты типизации
# Пока мы разбирали примеры аннотации простых типов данных, таких как строки и числа. Но часто вы будете иметь дело
# с составными типами данных, такими как списки, кортежи, словари и множества. Причем сама составная коллекция включает
# в себя, как правило, элементы других типов. И тут нужно начинать думать такими категориями как список строк,
# множество чисел, кортеж кортежей чисел и так далее. Для аннотации составных коллекций сейчас в python существует
# два подхода
# Использование модуля typing (актуально для программ, написанных на версиях ниже python 3.9)
# Встроенные возможности типизации (актуально для свежих версии python >= 3.9)
#
# Первый способ работает как на старых версиях python, так и на новых. Второй способ - только начиная с версии python 3.9.
# Но не смотря на это, мы рассмотрим оба способа аннотации, потому что вероятность встретить каждый из них в коде
# 50 на 50 %.
# Аннотации, так же как docstring и комментарии, не являются обязательными элементами вашей программы. Код работает и
# без этих инструментов, но признаком хорошего тона является их использование.

# Находим первый дубль
# Напишите функцию get_first_repeated_word, которая имеет один параметр words - список, состоящий из нескольких слов.
# Функция должна найти первый элемент, который образует дубль с ранее стоящими элементами, и вернуть его в качестве
# результата. Если передан список, в котором все слова различны, функция get_first_repeated_word должна вернуть None
# Регистр букв при сравнении нужно учитывать
#
# Для функции  get_first_repeated_word  дополнительно нужно добавить
# 1/док - строку Находит первый дубль в списке
# 2/аннотации при помощи модуля typing

from typing import List, Optional


def get_first_repeated_word(words: List[str]) -> Optional[str]:
    """Находит первый дубль в списке"""

    double = []
    for i in words:
        if i not in double:
            double.append(i)
        elif i in double:
            return i
    return

print(get_first_repeated_word.__doc__)
print(get_first_repeated_word.__annotations__)
print(get_first_repeated_word(['hello', 'hi', 'Hello']))
